1. Что выведет программа? Объяснить вывод программы. 
	Ответ: [77, 78, 79] выведет слайс с 1 по 4 элемент не включая

	package main

	import (
		"fmt"
	)
	func main() {
		a := [5]int{76, 77, 78, 79, 80}
		var b []int = a[1:4]
		fmt.Println(b)
	}

---------------------------------------------------------------------
2. Что выведет программа? Объяснить вывод программы. 
Объяснить как работают defer’ы и порядок их вызовов.
	Ответ: 
	2
	1
	Деферы выполняются после завершения всех строк в методе.
	Defer не может изменить неименованную переменную, которую возращает функцию, а именнованную, даже после return - может 

	package main

	import (
		"fmt"
	)

	func test() (x int) {
		defer func() {
			x++ 
		}()
		x = 1
		return 
	}

	func anotherTest() int {
		var x int
		defer func() {
			x++
		}()
		x = 1 
		return x
	}

	func main() {
		fmt.Println(anotherTest())
		fmt.Println(test())
	}

---------------------------------------------------------------------
3. Что выведет программа? Объяснить вывод программы. 
Объяснить внутреннее устройство интерфейсов и их отличие от пустых интерфейсов.
Ответ:
	<nil>
	false

	Интерфейс — это две составляющие: набор методов и тип.
	В go интерфейс представлен либо структурой iface, либо eface(пустой интерфейс).
	В функции Foo() мы создаём переменную типа указатель на тип os.PathError. 
	Тип os.PathError - это копия типа fs.PathError(вместе с методами).
	Значение переменной err внутри Foo() равно nil, поэтому первый вызов Println(err) выведет <nil>
	Во втором вызове Println(err == nil) err уже не конкретный тип, а интерфейс error. 
	Интерфейс равен nil тогда и только тогда, когда оба поля структуры iface/eface равны nil. 
	Так как мы "обернули" наш тип в интерфейс, то у этого интерфейса поля tab и data не nil. 
	Следовательно, сравнение err c nil в main вернёт false.


	package main

	import (
		"fmt"
		"os" 
	)

	func Foo() error {
		var err *os.PathError = nil
		return err
	}

	func main() {
		err := Foo()
		fmt.Println(err)
		fmt.Println(err == nil)
	}

---------------------------------------------------------------------
4. Что выведет программа? Объяснить вывод программы.
Ответ: Выведет с 0 по 9, далее произойдет дедлок. 
Он возникает из-за чтения из канала, в который никто не пишет. 
Для предотвращения дедлока в данной программе после цикла for необходимо закрыть канал.


	package main

	func main() {
		ch := make(chan int)
		go func() {
			for i := 0; i < 10; i++ {
				ch <- i
			}
		}()
		for n := range ch {
			println(n)
		} 
	}

---------------------------------------------------------------------
5. Что выведет программа? Объяснить вывод программы.
Ответ: error
На второй строке функции main мы присваиваем переменной типа интерфейс error конкретное значение - 
переменную типа указатель на структуру customError. 
Мы можем это сделать, так как *customError реализует интерфейс error. 
Так как интерфейс содержит информацию о конкретном типе, его сравнение с nil выдаст false.

	package main

	type customError struct {
			msg string
	}

	func (e *customError) Error() string {
		return e.msg
	}

	func test() *customError {
		{
			// do something
		}
		return nil 
	}

	func main() {
		var err error
		err = test()
		if err != nil {
			println("error")
			return
		}
		println("ok")
	}

---------------------------------------------------------------------
6. Что выведет программа? Объяснить вывод программы. 
Рассказать про внутреннее устройство слайсов и что происходит при передаче их в качестве аргументов функции.
Ответ:  [3 2 3]
слайс - ссылочный тип. В слайсе содержится ссылка на базовый массив. 
Длину слайса и емкость (сколько элементов влезет от 0 элемнта слайса до последего эл-та массива)
когда modifySlice изменил 0 элемент - это изменение отразилось и в передаваемом слайсе, 
потому что базовый срез был передан по ссылке
Но когда modifySlice добавил элемент, то тут пришлось расширять базовый массив. 
В новый массив (емкость которого стала в 2 раза больше) были скопированы все эл-ты из прошлого массива, 
к новому базовому массиву уже добавлен след элемент.
Но эти изменения не коснулись s срез, потому что у него не была изменена ссылка на базовый массив. 
Она была изменена только у копии среза.

	package main
	import (
		"fmt"
	)

	func main() {
		var s = []string{"1", "2", "3"}
		modifySlice(s)
		fmt.Println(s)
	}

	func modifySlice(i []string) {
		i[0] = "3"
		i = append(i, "4")
		i[1] = "5"
		i = append(i, "6")
	}

---------------------------------------------------------------------
7. Что выведет программа? Объяснить вывод программы.
Ответ: 
Выдедется от 1 до 8, далее будет чтение из закрытого канала, как следствие происходит зацикливание вывода 0.
Функция merge не обрабатывает случай, когда каналы закрыты.

	package main
	import (
		"fmt"
		"math/rand"
		"time"
	)

	func asChan(vs ...int) <-chan int {
		c := make(chan int)
		go func() {
			for _, v := range vs {
				c <- v
				time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
			}
		close(c) 
		}()
	return c 
	}

	func merge(a, b <-chan int) <-chan int {
		c := make(chan int)
		go func() {
			for {
				select {
					case v := <-a:
							c <- v
					case v := <-b:
							c <- v
				} 
			}
		}()
		return c 
	}

	func main() {
		a := asChan(1, 3, 5, 7)
		b := asChan(2, 4 ,6, 8)
		c := merge(a, b )

		for v := range c {
			fmt.Println(v)
		}
	}
